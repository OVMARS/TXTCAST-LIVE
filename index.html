<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TXTCAST FEED</title>
  <script src="https://unpkg.com/@solana/web3.js@1.75.1/lib/index.iife.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  <style>
    body { background: #000; margin: 0; padding: 0; font-family: 'Fira Code', monospace; color: #0f0; }
    .wrapper { max-width: 800px; margin: 3em auto; background: #111; padding: 2em; border-radius: 12px; box-shadow: 0 0 20px #0f03; }
    h1 { font-size: 1.8em; color: #fff; text-align: center; margin-bottom: 1em; }
    .memo-box {
        background: #000;
        padding: 1em;
        border-radius: 10px;
        border: 1px solid #333;
        height: 400px; /* Slightly increased height for list */
        overflow-y: auto;
        font-size: 10px; /* Smaller font size */
        white-space: pre-wrap;
        word-wrap: break-word;
        line-height: 3;
        color: #ffffff;
        text-shadow: /* Green glow effect */
            0 0 1px #0f0,
            0 0 1px #0f0,
            0 0 5px #0f0,
            0 0 2px #070;
    }
    .memo-item { /* Styling for each memo in the list */
        padding: 0.5em 0;
        border-bottom: 1px dashed #222; /* Softer separator */
    }
    .memo-item:last-child {
        border-bottom: none;
    }
    /* No cursor needed for list display */
    .status { color: #888; font-size: 12px; margin-top: 1em; text-align: center; }
    .rpc-warning { display: none !important; }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>📡 TXTCAST FEED</h1>
    <div class="memo-box" id="memoDisplay">Initializing...</div>
    <div class="status" id="statusDisplay">Connecting to Solana RPC...</div>
    <div class="rpc-warning" id="rpcWarningMessage"></div>
  </div>

  <script>
    // --- Configuration ---
    const HELIUS_PUBLIC_EXAMPLE_KEY = "34ea16bb-80b2-4e57-ad72-e94ecda7028a";
    const CORRECT_MEMO_PROGRAM_ID = "MemoSq4gqABAXKb96qnH8TysNcVtrp5GcC9YGN9qET9";

    const RPC_URLS = [
      `https://mainnet.helius-rpc.com/?api-key=${HELIUS_PUBLIC_EXAMPLE_KEY}`,
      "https://api.mainnet-beta.solana.com",
    ];

    const WALLET_ADDRESS = "9Er7ydwgEXhun5L2mHmmcjBP5qUxLYFF44PuQttNo2Sx";
    const FETCH_LIMIT_SIGS = 100;
    const MAX_SIGNATURE_PAGES_TO_FETCH = 7; // How many pages of signatures to check
    const DELAY_PER_TRANSACTION_MS = 150; // Increased delay to be safer with public RPC
    const REFRESH_INTERVAL_MS = 240000; // 4 minutes, less frequent refreshes

    let rpcIndex = 0;
    let walletPublicKey;
    let memoDisplayDiv;
    let statusDiv;

    function initializeDOMElements() {
        memoDisplayDiv = document.getElementById('memoDisplay');
        statusDiv = document.getElementById('statusDisplay');
        if (!memoDisplayDiv || !statusDiv) {
            console.error("CRITICAL: UI DOM elements (memoDisplay or statusDisplay) not found.");
            document.body.innerHTML = "<h1 style='color:red; text-align:center;'>Critical Error: UI Elements Missing. Check Console.</h1>";
            return false;
        }
        memoDisplayDiv.innerHTML = "Initializing..."; // Initial state
        return true;
    }

    const getConnection = () => {
        const activeRpcUrl = RPC_URLS[rpcIndex % RPC_URLS.length];
        console.log(`[Connection] Using RPC: ${activeRpcUrl.split('?')[0]}`);
        return new solanaWeb3.Connection(activeRpcUrl, "confirmed");
    };

    function extractMemoFromInstruction(ix) {
        let memoData = "";
        if (ix.program === "spl-memo") {
            if (ix.parsed && typeof ix.parsed === 'object' && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
                memoData = ix.parsed.info.memo;
            } else if (typeof ix.parsed === 'string') { // Key finding for Helius public key
                memoData = ix.parsed;
            }
        } else if (!ix.program && ix.parsed && typeof ix.parsed === 'object' && ix.parsed.type === "memo" && ix.parsed.info && typeof ix.parsed.info.memo === 'string') {
            memoData = ix.parsed.info.memo;
        } else if (ix.programId && ix.programId.toString() === CORRECT_MEMO_PROGRAM_ID && typeof ix.data === 'string') {
            try {
                memoData = new TextDecoder().decode(solanaWeb3.utils.bytes.bs58.decode(ix.data));
            } catch (e) { console.warn("Error decoding raw SPL Memo data:", e.message); }
        }
        return memoData.trim();
    }

    async function fetchAllTxtcastMemos() {
        if (!walletPublicKey) {
            console.error("Wallet PublicKey not initialized.");
            if (statusDiv) statusDiv.textContent = "Error: Wallet not initialized.";
            return [];
        }
        const connection = getConnection();
        if (statusDiv) statusDiv.textContent = `📡 Fetching from ${connection.rpcEndpoint.split('/')[2]}... (this may take a moment)`;

        const allFoundMemos = new Set();
        let beforeSig = null;
        let pagesFetched = 0;
        let totalSignaturesChecked = 0;

        try {
            while (pagesFetched < MAX_SIGNATURE_PAGES_TO_FETCH) {
                const options = { limit: FETCH_LIMIT_SIGS };
                if (beforeSig) options.before = beforeSig;
                
                console.log(`[FetchMemos] Fetching signatures page ${pagesFetched + 1}/${MAX_SIGNATURE_PAGES_TO_FETCH}, before: ${beforeSig || 'N/A'}`);
                if (statusDiv) statusDiv.textContent = `📡 Fetching signatures (Page ${pagesFetched + 1})...`;
                
                const signaturesInfo = await connection.getSignaturesForAddress(walletPublicKey, options);

                if (!signaturesInfo || signaturesInfo.length === 0) {
                    console.log(`[FetchMemos] No more signatures found on page ${pagesFetched + 1}.`);
                    break; 
                }
                console.log(`[FetchMemos] Found ${signaturesInfo.length} signatures on page ${pagesFetched + 1}. Processing...`);
                totalSignaturesChecked += signaturesInfo.length;

                for (let i = 0; i < signaturesInfo.length; i++) {
                    const sigInfo = signaturesInfo[i];
                    if (statusDiv) statusDiv.textContent = `📡 Processing TX ${i+1}/${signaturesInfo.length} of Page ${pagesFetched+1}...`;
                    
                    try {
                        const tx = await connection.getParsedTransaction(sigInfo.signature, {
                            commitment: "confirmed",
                            maxSupportedTransactionVersion: 0
                        });

                        if (!tx?.transaction?.message) {
                            console.warn(`[FetchMemos] Could not get full parsed tx for ${sigInfo.signature}`);
                            continue;
                        }

                        const instructions = [
                            ...(tx.transaction.message.instructions || []),
                            ...((tx.meta?.innerInstructions || []).flatMap(instr => instr.instructions) || [])
                        ];

                        for (const ix of instructions) {
                            const memo = extractMemoFromInstruction(ix);
                            if (memo && /^TXTCAST/i.test(memo)) {
                                console.log(`[FetchMemos] TXTCAST Found: "${memo.substring(0,40)}..."`);
                                allFoundMemos.add(memo);
                                break; 
                            }
                        }
                    } catch (txError) {
                        console.error(`[FetchMemos] Error processing tx ${sigInfo.signature}:`, txError.message);
                        if (String(txError).toLowerCase().includes("rate limit") || String(txError).includes("429")) {
                            console.warn("[FetchMemos] Hit rate limit. Will switch RPC on next main fetch attempt.");
                            throw txError; // Re-throw to trigger outer catch and RPC switch
                        }
                        // For other errors, we might just skip this transaction and continue
                    }
                    // More conservative delay
                    await new Promise(resolve => setTimeout(resolve, DELAY_PER_TRANSACTION_MS));
                }

                beforeSig = signaturesInfo[signaturesInfo.length - 1].signature;
                pagesFetched++;

                if (signaturesInfo.length < FETCH_LIMIT_SIGS) {
                    console.log("[FetchMemos] Last page of signatures reached (batch smaller than limit).");
                    break;
                }
            } // end while loop for pages

            const memosArray = Array.from(allFoundMemos);
            console.log(`[FetchMemos] Finished. Checked ~${totalSignaturesChecked} transactions. Found ${memosArray.length} unique TXTCAST memos.`);
            return memosArray.reverse(); // Typically, newest transactions are fetched first by getSignaturesForAddress. Reverse to show oldest first in list.

        } catch (error) { // Catch errors from getSignaturesForAddress or re-thrown errors
            console.error(`[FetchMemos] Major RPC error with ${connection.rpcEndpoint.split('?')[0]}:`, error.message);
            rpcIndex = (rpcIndex + 1) % RPC_URLS.length; // Try next RPC
            if (statusDiv) statusDiv.textContent = `RPC Error. Trying next: ${RPC_URLS[rpcIndex % RPC_URLS.length].split('/')[2]}...`;
            await new Promise(resolve => setTimeout(resolve, 5000)); // Wait longer before retrying full fetch
            return fetchAllTxtcastMemos(); // Recursive call to try next RPC / method
        }
    }

    function renderMemoList(memos) {
        if (!memoDisplayDiv) return;
        memoDisplayDiv.innerHTML = ''; // Clear previous "Initializing..." or "Loading..."

        if (!memos || memos.length === 0) {
            memoDisplayDiv.textContent = "No TXTCAST memos found to display.";
            return;
        }

        memos.forEach(memoText => {
            const memoElement = document.createElement('div');
            memoElement.className = 'memo-item';
            memoElement.textContent = memoText;
            memoDisplayDiv.appendChild(memoElement);
        });
    }

    async function updateAndDisplayMemos() {
        // Ensure DOM elements are ready (should be due to DOMContentLoaded)
        if (!memoDisplayDiv || !statusDiv) {
            console.error("UI elements not available for update.");
            return;
        }

        console.log("[UpdateCycle] Starting update...");
        statusDiv.textContent = "🔄 Fetching latest TXTCAST memos...";
        memoDisplayDiv.innerHTML = "⌛ Loading memos..."; // Show loading in memo box

        const fetchedMemos = await fetchAllTxtcastMemos();
        renderMemoList(fetchedMemos);

        if (statusDiv) {
            if (fetchedMemos.length > 0) {
                statusDiv.textContent = `✅ Displaying ${fetchedMemos.length} TXTCAST memo(s). Refreshes every ${REFRESH_INTERVAL_MS / 60000} mins.`;
            } else {
                statusDiv.textContent = `✅ Connected — No TXTCAST memos found this cycle. Will retry.`;
            }
        }
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        if (!initializeDOMElements()) {
            return; // Stop if UI elements are not found
        }

        try {
            walletPublicKey = new solanaWeb3.PublicKey(WALLET_ADDRESS);
        } catch (e) {
            console.error("Invalid Wallet Address:", WALLET_ADDRESS, e);
            if (statusDiv) statusDiv.textContent = "ERROR: Invalid Wallet Address.";
            if (memoDisplayDiv) memoDisplayDiv.innerHTML = "Configuration Error.";
            return;
        }

        if (RPC_URLS.length === 0) {
            if(statusDiv) statusDiv.textContent = "ERROR: No RPC URLs configured.";
            if(memoDisplayDiv) memoDisplayDiv.innerHTML = "RPC Configuration Error.";
        } else {
            updateAndDisplayMemos(); // Initial fetch and display
            setInterval(updateAndDisplayMemos, REFRESH_INTERVAL_MS); // Periodically refresh
        }
    });
  </script>
</body>
</html>
